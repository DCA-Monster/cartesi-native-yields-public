// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

// THIS FILE WAS AUTOMATICALLY GENERATED BY `generate_enum_proc.lua`,
// WITH ARGUMENT `code-generation-scripts/enum-data/splice_machine`,
// AND OUTPUT AT `src/splice/SpliceMachineEnum.sol`.

import "./SpliceMachine.sol";

library SpliceMachineEnum {

    // let type SpliceMachineEnum.T =
    //     | WaitingSpliceClaim of SpliceMachine.WaitingSpliceClaim
    //     | WaitingAgreement of SpliceMachine.WaitingAgreement

    enum Tag {
        WaitingSpliceClaim,
        WaitingAgreement
    }

    struct T {
        Tag _tag;
        bytes _data;
    }

    //
    // `WaitingSpliceClaim` methods
    //

    function enumOfWaitingSpliceClaim(
        SpliceMachine.WaitingSpliceClaim memory x
    ) external pure returns (T memory) {
        return T(Tag.WaitingSpliceClaim, abi.encode(x));
    }

    function isWaitingSpliceClaimVariant(
        T memory t
    ) external pure returns (bool) {
        return t._tag == Tag.WaitingSpliceClaim;
    }

    function getWaitingSpliceClaimVariant(
        T memory t
    ) external pure returns (SpliceMachine.WaitingSpliceClaim memory) {
        require(t._tag == Tag.WaitingSpliceClaim);
        return abi.decode(t._data, (SpliceMachine.WaitingSpliceClaim));
    }


    //
    // `WaitingAgreement` methods
    //

    function enumOfWaitingAgreement(
        SpliceMachine.WaitingAgreement memory x
    ) external pure returns (T memory) {
        return T(Tag.WaitingAgreement, abi.encode(x));
    }

    function isWaitingAgreementVariant(
        T memory t
    ) external pure returns (bool) {
        return t._tag == Tag.WaitingAgreement;
    }

    function getWaitingAgreementVariant(
        T memory t
    ) external pure returns (SpliceMachine.WaitingAgreement memory) {
        require(t._tag == Tag.WaitingAgreement);
        return abi.decode(t._data, (SpliceMachine.WaitingAgreement));
    }
}

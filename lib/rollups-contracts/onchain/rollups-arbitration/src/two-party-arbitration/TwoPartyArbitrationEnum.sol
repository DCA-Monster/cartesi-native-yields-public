// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

// THIS FILE WAS AUTOMATICALLY GENERATED BY `generate_enum_proc.lua`,
// WITH ARGUMENT `code-generation-scripts/enum-data/two_party_arbitration`,
// AND OUTPUT AT `src/two-party-arbitration/TwoPartyArbitrationEnum.sol`.

import "src/partition/PartitionEnum.sol";
import "src/epoch-hash-split/EpochHashSplitEnum.sol";
import "src/splice/SpliceMachineEnum.sol";
import "src/memory-manager/MemoryManager.sol";

library TwoPartyArbitrationEnum {

    // let type TwoPartyArbitrationEnum.T =
    //     | InputPartition of PartitionEnum.T
    //     | EpochHashSplit of EpochHashSplitEnum.T
    //     | MachineSplice of SpliceMachineEnum.T
    //     | InstructionPartition of PartitionEnum.T
    //     | ProveMemory of MemoryManager.Context

    enum Tag {
        InputPartition,
        EpochHashSplit,
        MachineSplice,
        InstructionPartition,
        ProveMemory
    }

    struct T {
        Tag _tag;
        bytes _data;
    }

    //
    // `InputPartition` methods
    //

    function enumOfInputPartition(
        PartitionEnum.T memory x
    ) external pure returns (T memory) {
        return T(Tag.InputPartition, abi.encode(x));
    }

    function isInputPartitionVariant(
        T memory t
    ) external pure returns (bool) {
        return t._tag == Tag.InputPartition;
    }

    function getInputPartitionVariant(
        T memory t
    ) external pure returns (PartitionEnum.T memory) {
        require(t._tag == Tag.InputPartition);
        return abi.decode(t._data, (PartitionEnum.T));
    }


    //
    // `EpochHashSplit` methods
    //

    function enumOfEpochHashSplit(
        EpochHashSplitEnum.T memory x
    ) external pure returns (T memory) {
        return T(Tag.EpochHashSplit, abi.encode(x));
    }

    function isEpochHashSplitVariant(
        T memory t
    ) external pure returns (bool) {
        return t._tag == Tag.EpochHashSplit;
    }

    function getEpochHashSplitVariant(
        T memory t
    ) external pure returns (EpochHashSplitEnum.T memory) {
        require(t._tag == Tag.EpochHashSplit);
        return abi.decode(t._data, (EpochHashSplitEnum.T));
    }


    //
    // `MachineSplice` methods
    //

    function enumOfMachineSplice(
        SpliceMachineEnum.T memory x
    ) external pure returns (T memory) {
        return T(Tag.MachineSplice, abi.encode(x));
    }

    function isMachineSpliceVariant(
        T memory t
    ) external pure returns (bool) {
        return t._tag == Tag.MachineSplice;
    }

    function getMachineSpliceVariant(
        T memory t
    ) external pure returns (SpliceMachineEnum.T memory) {
        require(t._tag == Tag.MachineSplice);
        return abi.decode(t._data, (SpliceMachineEnum.T));
    }


    //
    // `InstructionPartition` methods
    //

    function enumOfInstructionPartition(
        PartitionEnum.T memory x
    ) external pure returns (T memory) {
        return T(Tag.InstructionPartition, abi.encode(x));
    }

    function isInstructionPartitionVariant(
        T memory t
    ) external pure returns (bool) {
        return t._tag == Tag.InstructionPartition;
    }

    function getInstructionPartitionVariant(
        T memory t
    ) external pure returns (PartitionEnum.T memory) {
        require(t._tag == Tag.InstructionPartition);
        return abi.decode(t._data, (PartitionEnum.T));
    }


    //
    // `ProveMemory` methods
    //

    function enumOfProveMemory(
        MemoryManager.Context memory x
    ) external pure returns (T memory) {
        return T(Tag.ProveMemory, abi.encode(x));
    }

    function isProveMemoryVariant(
        T memory t
    ) external pure returns (bool) {
        return t._tag == Tag.ProveMemory;
    }

    function getProveMemoryVariant(
        T memory t
    ) external pure returns (MemoryManager.Context memory) {
        require(t._tag == Tag.ProveMemory);
        return abi.decode(t._data, (MemoryManager.Context));
    }
}
